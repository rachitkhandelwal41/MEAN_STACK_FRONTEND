---
context: true
priority: high
scope: project
---

# Frontend Development Context - Healthcare Management Portal

## Project Overview

Healthcare Management Portal with role-based access for:
- **Patients**: Register, search doctors, book/cancel appointments, view prescriptions, pay bills
- **Doctors**: Manage appointments, diagnose patients, prescribe medicines, set availability
- **Admins**: Manage doctors, departments, billing records, generate reports

**Tech Stack**: Angular (standalone), TypeScript, TailwindCSS, PostgreSQL backend via REST API

## Angular CLI Usage

**ALWAYS use Angular CLI for generation:**
```bash
# Components
ng generate component features/patient/dashboard --skip-tests

# Services
ng generate service core/services/appointment --skip-tests

# Guards
ng generate guard core/guards/auth --skip-tests

# Interceptors
ng generate interceptor core/interceptors/auth --skip-tests

# Pipes
ng generate pipe shared/pipes/date-format --skip-tests
```

**Note**: Use `--skip-tests` flag unless tests are explicitly requested.

## Core Principles

- **Deep Reasoning**: Analyze problem thoroughly before implementation
- **No Tests/Docs**: Never generate test files, README, or .md files unless explicitly requested
- **CLI First**: Always use Angular CLI for file generation
- **Backend Integration**: All data from REST API via services
- **TailwindCSS Only**: Use Tailwind utility classes for all styling
- **Healthcare Focus**: Prioritize accessibility, data privacy, UX

## TypeScript Standards

- Strict mode enabled (`strict: true`)
- No `any` type - use `unknown` or proper types
- Define interfaces matching backend DTOs
- Use enums for status values:
```typescript
export enum AppointmentStatus {
  BOOKED = 'BOOKED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

export enum UserRole {
  PATIENT = 'PATIENT',
  DOCTOR = 'DOCTOR',
  ADMIN = 'ADMIN'
}
```

## Angular Architecture

**Standalone Components (Default)**
- No NgModules, no `standalone: true` in decorators
- Use `imports` array for dependencies
- Lazy load feature routes

**Component Structure**
- Use `inject()` function for DI (not constructor injection)
- Use `input()` and `output()` functions (not decorators)
- Set `changeDetection: ChangeDetectionStrategy.OnPush`
- Use `host` object instead of `@HostBinding`/`@HostListener`
- Use native control flow: `@if`, `@for`, `@switch`

**State Management**
- Use signals for component state
- Use `computed()` for derived values
- Use `update()` or `set()` on signals (NOT `mutate()`)

## Service Layer (Backend Integration)

**Service Pattern**
```typescript
import { inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export class AppointmentService {
  private http = inject(HttpClient);
  private apiUrl = '/api/appointments';

  getAppointments(): Observable<Appointment[]> {
    return this.http.get<Appointment[]>(this.apiUrl);
  }

  bookAppointment(data: BookingRequest): Observable<Appointment> {
    return this.http.post<Appointment>(this.apiUrl, data);
  }
}
```

**Service Organization**
- One service per domain: `PatientService`, `DoctorService`, `AppointmentService`, `BillingService`
- Use `providedIn: 'root'` for singleton services
- Return Observables from HTTP calls
- Convert to signals in components using `toSignal()`
- Implement error handling with typed errors
- Use interceptors for auth tokens and global error handling

## Forms with Backend

**Reactive Forms Pattern**
```typescript
import { inject } from '@angular/core';
import { FormBuilder, Validators } from '@angular/forms';

export class BookingComponent {
  private fb = inject(FormBuilder);
  private appointmentService = inject(AppointmentService);

  bookingForm = this.fb.nonNullable.group({
    doctorId: ['', Validators.required],
    appointmentDate: ['', Validators.required],
    notes: ['']
  });

  onSubmit() {
    if (this.bookingForm.valid) {
      this.appointmentService
        .bookAppointment(this.bookingForm.getRawValue())
        .subscribe({
          next: (appointment) => {
            // Handle success
          },
          error: (error) => {
            // Handle error
          }
        });
    }
  }
}
```

## TailwindCSS Styling

**Core Principles**
- Use Tailwind utility classes exclusively
- No custom CSS unless absolutely necessary
- No `ngClass` or `ngStyle` - use direct class/style bindings:
```html
<div [class.bg-green-500]="status === 'COMPLETED'"
     [class.bg-blue-500]="status === 'BOOKED'">
```

**Common Patterns**
```html
<!-- Cards -->
<div class="bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow">

<!-- Buttons -->
<button class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 
               disabled:opacity-50 disabled:cursor-not-allowed">

<!-- Forms -->
<input class="w-full px-3 py-2 border border-gray-300 rounded-md 
              focus:outline-none focus:ring-2 focus:ring-blue-500">

<!-- Spacing Scale -->
<!-- Use: p-4, m-4, gap-4, space-y-4 (4px increments: 4, 8, 12, 16, 24, 32) -->

<!-- Responsive -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">

<!-- Loading States -->
<div class="animate-pulse bg-gray-200 h-20 rounded-md"></div>
```

**Color Scheme**
- Primary: `blue-600`, `blue-700`
- Success: `green-500`, `green-600`
- Warning: `yellow-500`, `yellow-600`
- Danger: `red-500`, `red-600`
- Neutral: `gray-100` to `gray-900`

## Data Models (Backend DTOs)

```typescript
export interface User {
  userId: number;
  username: string;
  email: string;
  phone: string;
  role: UserRole;
}

export interface Patient {
  patientId: number;
  userId: number;
  age: number;
  gender: string;
  bloodGroup: string;
}

export interface Doctor {
  doctorId: number;
  userId: number;
  deptId: number;
  specialization: string;
  availability: string;
}

export interface Appointment {
  appointmentId: number;
  patientId: number;
  doctorId: number;
  appointmentDate: string; // ISO date string
  status: AppointmentStatus;
}

export interface Prescription {
  prescriptionId: number;
  appointmentId: number;
  doctorNotes: string;
  medicines: string;
}

export interface Department {
  deptId: number;
  name: string;
}
```

## Routing & Guards

**Route Structure**
```typescript
export const routes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', loadComponent: () => import('./features/auth/login.component') },
  {
    path: 'patient',
    canActivate: [authGuard, roleGuard(UserRole.PATIENT)],
    loadChildren: () => import('./features/patient/patient.routes')
  },
  {
    path: 'doctor',
    canActivate: [authGuard, roleGuard(UserRole.DOCTOR)],
    loadChildren: () => import('./features/doctor/doctor.routes')
  },
  {
    path: 'admin',
    canActivate: [authGuard, roleGuard(UserRole.ADMIN)],
    loadChildren: () => import('./features/admin/admin.routes')
  }
];
```

**Guards Implementation**
- `authGuard`: Check authentication status
- `roleGuard`: Verify user role matches route requirement
- Use functional guards with `inject()`

## Folder Structure

```
src/app/
├── core/
│   ├── guards/
│   │   ├── auth.guard.ts
│   │   └── role.guard.ts
│   ├── interceptors/
│   │   ├── auth.interceptor.ts
│   │   └── error.interceptor.ts
│   └── services/
│       ├── auth.service.ts
│       ├── patient.service.ts
│       ├── doctor.service.ts
│       ├── appointment.service.ts
│       └── billing.service.ts
├── shared/
│   ├── components/
│   │   ├── header/
│   │   ├── footer/
│   │   └── loading-spinner/
│   └── pipes/
│       └── date-format.pipe.ts
├── features/
│   ├── auth/
│   │   └── login/
│   ├── patient/
│   │   ├── dashboard/
│   │   ├── appointments/
│   │   ├── search-doctors/
│   │   └── prescriptions/
│   ├── doctor/
│   │   ├── dashboard/
│   │   ├── appointments/
│   │   └── prescriptions/
│   └── admin/
│       ├── dashboard/
│       ├── doctors/
│       ├── departments/
│       └── billing/
└── models/
    ├── user.model.ts
    ├── patient.model.ts
    ├── doctor.model.ts
    ├── appointment.model.ts
    └── prescription.model.ts
```

## Key Features Implementation

**Appointment Booking Flow**
1. Search doctors (filters: specialization, availability)
2. Select doctor and view available slots
3. Book appointment (real-time validation)
4. Show confirmation with details

**Doctor Dashboard**
- Today's appointments list
- Quick actions (view patient, add prescription)
- Update availability

**Patient Dashboard**
- Upcoming appointments
- Recent prescriptions
- Medical history
- Pending bills

**Admin Panel**
- Doctor management (CRUD)
- Department management
- Billing records
- Reports generation

## Accessibility

- Use semantic HTML: `<button>`, `<nav>`, `<main>`, `<aside>`
- Add ARIA labels: `aria-label`, `aria-describedby`
- Ensure keyboard navigation (tab order, focus management)
- Color contrast WCAG AA compliant
- Alt text for images
- Screen reader announcements for dynamic content

## Error Handling

```typescript
// In components
this.appointmentService.getAppointments().subscribe({
  next: (appointments) => this.appointments.set(appointments),
  error: (error) => {
    this.errorMessage.set('Failed to load appointments. Please try again.');
    console.error('Error loading appointments:', error);
  }
});

// Global error interceptor
export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  return next(req).pipe(
    catchError((error: HttpErrorResponse) => {
      // Handle global errors
      return throwError(() => error);
    })
  );
};
```

## Performance Optimization

- Use `OnPush` change detection
- Implement virtual scrolling for large lists (CDK)
- Lazy load all feature routes
- Use `@defer` for below-fold content
- Add `trackBy` in `@for` loops
- Debounce search inputs (300ms)
- Implement pagination for large datasets

## Security

- Never store tokens in localStorage (use httpOnly cookies)
- Sanitize user inputs (Angular built-in)
- Implement auth token refresh
- Use route guards for protected routes
- Role-based UI rendering
- Validate on both client and server

## Critical Reminders

**ALWAYS use Angular CLI** for generating files
**Backend Integration** - all data via REST API services
**TailwindCSS only** - no custom CSS, use utility classes
**No tests/docs** unless explicitly requested
**Use `inject()`** not constructor injection
**Signals for state** not RxJS subjects
**Native control flow** (`@if`, `@for`, `@switch`)
**Standalone components** - no NgModules
**Deep reasoning** before implementation
**Accessibility first** - semantic HTML, ARIA, keyboard nav